//Generate a planar triangulation
//Input: node file, ele files, neigh file
//output: pg file, hedge file

//node file (.node): node file format with the border index https://www.cs.cmu.edu/~quake/triangle.node.html
//ele file (.ele): ele file format https://www.cs.cmu.edu/~quake/triangle.ele.html
//neigh file (.neigh): neigh file format https://www.cs.cmu.edu/~quake/triangle.neigh.html
//pg file (.pg): file necessary to compress polylla, first edge and last edge of vertex 0 are border edges
//hedge file (.hedge): file necessary plot triangulation


// half-edge triangulation CLASS
/*
Basic operations
    incident_face(e): return the face incident to e
    twin(e): return the twin halfedge of e
    next(e): return the next halfedge of e
    prev(e): return the previous halfedge of e
    origin(e): return the first vertex of halfedge e
    target(e): return the second vertex of halfedge e
Others
    CCW_edge_to_vertex(e): return the next CCW edge incident to v after e
    edge_of_vertex(v): return A edge incident to v
    is_border_face(e): return true if the incent face of e is a border face
    is_interior(e): return true if the incent face of e is an interior face
    is_border_vertex(e): return true if the vertex v is part of the boundary
    faces(): return number of faces
    halfEdges(): Return number of halfedges
    vertices(): Return number of vertices
    get_Triangles(): bitvector of triangles where true if the halfege generate a unique face, false if the face is generated by another halfedge
    get_PointX(uint i): return the i-th x coordinate of the triangulation
    get_PointY(uint i): return the i-th y coordinate of the triangulation

TODO:
    edge_iterator;
    face_iterator;
    vertex_iterator;
    copy constructor;
    constructor indepent of triangle
*/


#include <array>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>

struct vertex{
    double x;
    double y;
    bool is_border = false; // if the vertex is on the boundary
    uint incident_halfedge; // halfedge incident to the vertex, vertex is the origin of the halfedge
};



struct halfEdge {
    uint origin; //tail of edge
    uint target; //head of edge
    uint twin; //opposite halfedge
    uint next; //next halfedge of the same face
    uint prev; //previous halfedge of the same face
    uint face = -1; //face index incident to the halfedge
    uint is_border; //1 if the halfedge is on the boundary, 0 otherwise
};

class Triangulation 
{

public:
    typedef std::array<uint,3> triangle; 
    uint n_halfedges = 0; //number of halfedges
    uint n_faces = 0; //number of faces
    uint n_vertices = 0; //number of vertices
    std::vector<vertex> Vertices;
    std::vector<halfEdge> HalfEdges; //list of edges
    std::vector<char> triangle_flags; //list of edges that generate a unique triangles, 

private:

    //Read node file in .node format and nodes in point vector
    void read_nodes_from_file(std::string name){
        std::string line;
        std::ifstream nodefile(name);
        double a1, a2, a3, a4;
        
        //std::cout<<"Node file"<<std::endl;
        if (nodefile.is_open())
        {
            nodefile >> n_vertices;
            //std::cout<<pnumber<<std::endl;
            Vertices.reserve(n_vertices);
            std::getline(nodefile, line); 
            while (nodefile >> a1 >> a2 >> a3 >> a4)
            {
                vertex ve;
                ve.x =  a2;
                ve.y =  a3;
                ve.is_border = (a4 == 1) ? true : false;
                Vertices.push_back(ve);
            }
        }
        else 
            std::cout << "Unable to open node file"; 
        nodefile.close();
    }
   //Read triangle file in .ele format and stores it in faces vector
    std::vector<uint> read_triangles_from_file(std::string name){
        std::vector<uint> faces;
        std::string line;
        std::ifstream elefile(name);
        int a1, a2, a3, a4;
        
        //std::cout<<"Node file"<<std::endl;
        if (elefile.is_open())
        {
            elefile >> n_faces;
            //std::cout<<pnumber<<std::endl;
            faces.reserve(n_faces);
            std::getline(elefile, line); 
            while (elefile >> a1 >> a2 >> a3 >> a4)
            {
                faces.push_back(a2);
                faces.push_back(a3);
                faces.push_back(a4);
                //std::cout<<"Vertex "<<a1<<" "<<v.x<<" "<<v.y<<" "<<v.is_border<<std::endl;
            }
        }
        else 
            std::cout << "Unable to open node file"; 
        elefile.close();

        return faces;
    }

    //Read node file in .node format and nodes in point vector
    std::vector<int>  read_neigh_from_file(std::string name){
        std::vector<int> neighs;
        std::string line;
        std::ifstream neighfile(name);
        int a1, a2, a3, a4;
        
        //std::cout<<"Node file"<<std::endl;
        if (neighfile.is_open())
        {
            neighfile >> n_faces;
            //std::cout<<pnumber<<std::endl;
            neighs.reserve(n_faces);
            std::getline(neighfile, line); 
            while (neighfile >> a1 >> a2 >> a3 >> a4)
            {
                neighs.push_back(a2);
                neighs.push_back(a3);
                neighs.push_back(a4);
                
            }
        }
        else 
            std::cout << "Unable to open node file"; 
        neighfile.close();
        return neighs;
    }

    //Generate interior halfedges using faces and neigh vectors
    //also associate each vertex with an incident halfedge
    void construct_interior_halfEdges(std::vector<uint> faces, std::vector<int> neighs){
        for(uint i = 0; i < n_faces; i++){
            halfEdge he0, he1, he2;
            uint index_he0 = i*3+0;
            uint index_he1 = i*3+1;
            uint index_he2 = i*3+2;
            uint v0 = faces[3*i+0];
            uint v1 = faces[3*i+1];
            uint v2 = faces[3*i+2];
            uint n0 = neighs[3*i+0];
            uint n1 = neighs[3*i+1];
            uint n2 = neighs[3*i+2];

            he0.origin = v0;
            he0.target = v1;
            he0.next = index_he1;
            he0.prev = index_he2;
            he0.face = i;
            he0.is_border = (n2 == -1);
            Vertices.at(v0).incident_halfedge = index_he0;
            if(n2 != -1){
                for (size_t j = 0; j < 3; j++)
                {
                    if(faces[3*n2 + j] == v1 && faces[3*n2 + (j + 1)%3] == v0){
                        he0.twin = 3*n2 + j;
                        break;
                    }
                }
            }else
                he0.twin = -1;

            HalfEdges.push_back(he0);
            
            he1.origin = v1;
            he1.target = v2;
            he1.next = index_he2;
            he1.prev = index_he0;
            he1.face = i;
            he1.is_border = (n0 == -1);
            
            Vertices.at(v1).incident_halfedge = index_he1;
            

            if(n0 != -1){
                for (size_t j = 0; j < 3; j++)
                {
                    if(faces[3*n0 + j] == v2 && faces[3*n0 + (j + 1)%3] == v1){
                        he1.twin = 3*n0 + j;
                        break;
                    }
                }
            }else
                he1.twin = -1;
            HalfEdges.push_back(he1);

            he2.origin = v2;
            he2.target = v0;
            he2.next = index_he0;
            he2.prev = index_he1;
            he2.face = i;
            he2.is_border = (n1 == -1);
            Vertices.at(v2).incident_halfedge = index_he2;

            if(n1 != -1)
                for (size_t j = 0; j < 3; j++)
                {
                    if(faces[3*n1 + j] == v0 && faces[3*n1 + (j + 1)%3] == v2){
                        he2.twin = 3*n1 + j;
                        break;
                    }
                }
            else
                he2.twin = -1;
            
            HalfEdges.push_back(he2);
        }
        this->n_halfedges = HalfEdges.size();
    }

    //Generate exterior halfedges
    //Literally calculates the convex hull
    //this takes O(n + k*k), with n the number of interior halfedges and k the number of exterior halfedges
    //optimize to a version n + k
    void construct_exterior_halfEdges(){
        //search interior edges labed as border, generates exterior edges
        //with the origin and target inverted and add at the of HalfEdges vector
        halfEdge he_aux;
        for(uint i = 0; i < n_halfedges; i++)
            if(HalfEdges.at(i).is_border){
                he_aux.target = HalfEdges.at(i).origin;
                he_aux.origin = HalfEdges.at(i).target;
                he_aux.is_border = true;
                HalfEdges.at(i).is_border = false;
                he_aux.twin = i;
                HalfEdges.push_back(he_aux);
                HalfEdges.at(i).twin = HalfEdges.size() - 1 ;
            }    
               
        
        //traverse the exterior edges and search their next prev halfedge
        uint v_origin, v_target;
        for(uint i = n_halfedges; i < HalfEdges.size(); i++){
            if(HalfEdges.at(i).is_border){
                //search prev of the halfedge
                for(uint j = n_halfedges; j < HalfEdges.size(); j++)
                    if(HalfEdges.at(j).origin == HalfEdges.at(i).target){
                        HalfEdges.at(j).prev = i;
                        break;
                    }
                //search next of each exterior edge   
                for(uint j = n_halfedges; j < HalfEdges.size(); j++)
                    if(HalfEdges.at(i).target == HalfEdges.at(j).origin){
                            HalfEdges.at(i).next = j;
                            break;
                    }
            }
        }

        this->n_halfedges = HalfEdges.size();
    }

public:

    //default constructor
    Triangulation() {}

    //Constructor from file
    Triangulation(std::string node_file, std::string ele_file, std::string neigh_file) {
        std::vector<uint> faces;
        std::vector<int> neighs;
        read_nodes_from_file(node_file);
        //fusionar estos dos métodos
        faces = read_triangles_from_file(ele_file);
        neighs = read_neigh_from_file(neigh_file);
        construct_interior_halfEdges(faces, neighs);
        construct_exterior_halfEdges();
        
        //true if the halfege generate a unique face, false if the face is generated by another halfedge
        triangle_flags.resize(n_halfedges, false);
        for(uint i = 0; i < n_faces; i++)
            triangle_flags.at(3*i) = true;

        //for(uint i = 0; i < n_halfedges; i++){
        //    triangle tr;
        //    if(triangle_flags[i]){
        //        tr = incident_face(i);
        //        std::cout<<"edge "<<i<<": "<<tr[0]<<"-"<<tr[1]<<"-"<<tr[2]<<std::endl;
        //    }
        //}

        std::cout<<"Generate halfedge.\nVertices "<<n_vertices<<", triangles: "<<n_faces<<", halfedges: "<<n_halfedges<<std::endl;
        //for(uint i = 0; i < n_vertices; i++){
        //    vertex v = Vertices.at(i);
        //    std::cout<<"Vertex "<<i<<" "<<v.x<<" "<<v.y<<" "<<v.is_border<<std::endl;
        //}

        //for(uint i = 0; i < n_vertices; i++){
        //    uint incident = Vertices.at(i).incident_halfedge;
        //    uint CCW_next = CCW_edge_to_vertex(incident);
        //    triangle tr = incident_face(incident);
        //    std::cout<<"Vertex "<<i<<" has edge indicent "<<origin(incident)<<"-"<<target(incident)<<" with face "<<tr[0]<<"-"<<tr[1]<<"-"<<tr[2]<<" and next CCW edge "<<origin(CCW_next)<<"-"<<target(CCW_next)<<std::endl;
        //}
    }

    //print the triangulation in pg file format
    void print_pg(std::string file_name){
        std::cout<<"Printing triangulation in pg format"<<std::endl;
        std::ofstream file;
        file.open(file_name);
        file<< n_vertices <<"\n";
        file<< n_halfedges/2 <<"\n";
        for(uint i = 0; i < n_vertices; i++){
            vertex v = Vertices.at(i);
            uint incident = v.incident_halfedge;
            uint curr = incident;
            uint twin = HalfEdges.at(curr).twin;
            //search border edges with v as origin
            if(v.is_border){
                while(!HalfEdges.at(twin).is_border){
                    curr = CCW_edge_to_vertex(curr);
                    twin = HalfEdges.at(curr).twin;
                }
            }
            file<<origin(curr)<<" "<<target(curr)<<"\n";
            uint nxt = CCW_edge_to_vertex(curr);
            while(nxt != curr){
                file<<origin(nxt)<<" "<<target(nxt)<<"\n";
                nxt = CCW_edge_to_vertex(nxt);
            }
        }
        file.close();
    }

    void print_hedge(std::string file_name){
        std::cout<<"Print halfedges"<<std::endl;
        std::ofstream file;
        file.open(file_name);
        file<<n_halfedges<<"\n";
        for(uint i = 0; i < n_halfedges; i++){
            halfEdge he = HalfEdges.at(i);
            file<<he.origin<<" "<<he.target<<"\n";
        }
        file.close();
    }

    uint face_index(uint i){
        return HalfEdges.at(i).face;
    }

    //Return triangle of the face incident to edge e
    //Input: e is the edge
    //output: array with the vertices of the triangle
    triangle incident_face(uint e)
    {   
        triangle face;  
        uint nxt = e;
        uint init_vertex = origin(nxt);
        uint curr_vertex = -1;
        uint i = 0;
        while ( i < 3 )
        {
            curr_vertex = origin(nxt);
            //std::cout<<"curr "<<curr_vertex<<std::endl;
            face[i] = curr_vertex;
            i++;
            nxt = next(nxt);            
           // std::cout<<"init: "<<init_vertex<<", curr: "<<curr_vertex<<", nxt: "<<origin(nxt)<<std::endl;
        }
        return face;
    }
    
    //function to check if a triangle is counterclockwise
    //Input: array with the vertices of the triangle
    //Output: true if the triangle is counterclockwise, false otherwise
    bool is_counterclockwise(triangle tr)
    {
        uint v0 = tr[0];
        uint v1 = tr[1];
        uint v2 = tr[2];
        double area = 0.0;
            //int val = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y);
        area = (Vertices.at(v2).x - Vertices.at(v1).x) * (Vertices.at(v1).y - Vertices.at(v0).y) - (Vertices.at(v2).y - Vertices.at(v1).y) * (Vertices.at(v1).x - Vertices.at(v0).x);
        if(area < 0)
            return true;
        else
            return false;
    }

    //Given a edge with vertex origin v, return the next coutnerclockwise edge of v with v as origin
    //Input: e is the edge
    //Output: the next counterclockwise edge of v
    uint CCW_edge_to_vertex(uint e)
    {
        uint twn, nxt;
        if(is_border_face(e)){
            nxt = HalfEdges.at(e).prev;
            twn = HalfEdges.at(nxt).twin;
            return twn;
        }
        nxt = HalfEdges.at(e).next;
        nxt = HalfEdges.at(nxt).next;
        twn = HalfEdges.at(nxt).twin;
        return twn;
        
    }    

    //Given a edge with vertex origin v, return the prev clockwise edge of v with v as origin
    //Input: e is the edge
    //Output: the prev clockwise edge of v
    uint CW_edge_to_vertex(uint e)
    {
        uint twn, prv, nxt;
        twn = HalfEdges.at(e).twin;
        nxt = HalfEdges.at(twn).next;
        return nxt;
    }    

    //return number of faces
    uint faces(){
        return n_faces;
    }

    //Return number of halfedges
    uint halfEdges(){
        return n_halfedges;
    }

    //Return number of vertices
    uint vertices(){
        return n_vertices;
    }

    //list of triangles where true if the halfege generate a unique face, false if the face is generated by another halfedge
    //Replace by a triangle iterator
    std::vector<char> get_Triangles(){
        return triangle_flags;
    }

    double get_PointX(uint i){
        return Vertices.at(i).x;
    }

    double get_PointY(uint i){
        return Vertices.at(i).y;
    }

    //Calculates the next edge of the face incident to edge e
    //Input: e is the edge
    //Output: the next edge of the face incident to e
    uint next(uint e){
        return HalfEdges.at(e).next;
    }

    //Calculates the tail vertex of the edge e
    //Input: e is the edge
    //Output: the tail vertex v of the edge e
    uint origin(uint e)
    {
        return HalfEdges.at(e).origin;
    }


    //Calculates the head vertex of the edge e
    //Input: e is the edge
    //Output: the head vertex v of the edge e
    uint target(uint e)
    {
        return HalfEdges.at(e).target;
    }

    //Return the twin edge of the edge e
    //Input: e is the edge
    //Output: the twin edge of e
    uint twin(uint e)
    {
        return HalfEdges.at(e).twin;
    }

    //Return the twin edge of the edge e
    //Input: e is the edge
    //Output: the twin edge of e
    uint prev(uint e)
    {
        return HalfEdges.at(e).prev;
    }



    //return a edge associate to the node v
    //Input: v is the node
    //Output: the edge associate to the node v
    uint edge_of_vertex(uint v)
    {
        return Vertices.at(v).incident_halfedge;
    }

    //Input: edge e
    //Output: true if is the face of e is border face
    //        false otherwise
    bool is_border_face(int e)
    {
        return HalfEdges.at(e).is_border;
    }

    // Input: edge e of compressTriangulation
    // Output: true if the edge is an interior face a
    //         false otherwise
    bool is_interior_face(uint e)
    {
       return !this->is_border_face(e);
    }

    //Input:vertex v
    //Output: the edge incident to v, wiht v as origin
    bool is_border_vertex(uint v)
    {
        return Vertices.at(v).is_border;
    }

};

int main(int argc, char *argv[])
{
    if(argc != 6)
    {
        std::cout<<"Usage: "<<argv[0]<<" <node_file .node> <ele_file .ele> <neigh_file .neigh> <output .pg> <output .hedge>"<<std::endl;
        return 0;
    }

    std::string node_file = std::string(argv[1]);
    std::string ele_file = std::string(argv[2]);
    std::string neigh_file = std::string(argv[3]);
    std::string output_pg = std::string(argv[4]);
    std::string output_hedge = std::string(argv[5]);

    if(node_file.substr(node_file.find_last_of(".") + 1) != "node"){
        std::cout<<"Error: node file must be .node"<<std::endl;
        return 0;
    }
    if(ele_file.substr(ele_file.find_last_of(".") + 1) != "ele"){
        std::cout<<"Error: ele file must be .ele"<<std::endl;
        return 0;
    }
    if(neigh_file.substr(neigh_file.find_last_of(".") + 1) != "neigh"){
        std::cout<<"Error: neigh file must be .neigh"<<std::endl;
        return 0;
    }
        

    Triangulation *tr = new Triangulation(node_file, ele_file, neigh_file);

    tr->print_pg(output_pg);
    tr->print_hedge(output_hedge);
    delete tr;
    return 0;
}